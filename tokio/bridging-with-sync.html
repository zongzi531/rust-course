<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>异步跟同步共存 - Rust语言圣经(Rust教程 Rust Course)</title>


        <!-- Custom HTML head -->

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../assets/ferris.css">
        <link rel="stylesheet" href="../assets/theme/2018-edition.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../into-rust.html">进入Rust编程世界</a></li><li class="chapter-item expanded affix "><a href="../about-book.html">关于本书</a></li><li class="chapter-item expanded affix "><a href="../sth-you-should-not-do.html">避免从入门到放弃</a></li><li class="chapter-item expanded "><a href="../first-try/intro.html"><strong aria-hidden="true">1.</strong> 寻找牛刀，以便小试</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../first-try/installation.html"><strong aria-hidden="true">1.1.</strong> 安装Rust环境</a></li><li class="chapter-item "><a href="../first-try/editor.html"><strong aria-hidden="true">1.2.</strong> 墙推VSCode!</a></li><li class="chapter-item "><a href="../first-try/cargo.html"><strong aria-hidden="true">1.3.</strong> 认识Cargo</a></li><li class="chapter-item "><a href="../first-try/hello-world.html"><strong aria-hidden="true">1.4.</strong> 不仅仅是Hello world</a></li></ol></li><li class="chapter-item expanded "><a href="../basic/intro.html"><strong aria-hidden="true">2.</strong> Rust基础入门</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../basic/variable.html"><strong aria-hidden="true">2.1.</strong> 变量绑定与解构</a></li><li class="chapter-item "><a href="../basic/base-type/index.html"><strong aria-hidden="true">2.2.</strong> 基本类型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../basic/base-type/numbers.html"><strong aria-hidden="true">2.2.1.</strong> 数值类型</a></li><li class="chapter-item "><a href="../basic/base-type/char-bool.html"><strong aria-hidden="true">2.2.2.</strong> 字符、布尔、单元类型</a></li><li class="chapter-item "><a href="../basic/base-type/statement-expression.html"><strong aria-hidden="true">2.2.3.</strong> 语句与表达式</a></li><li class="chapter-item "><a href="../basic/base-type/function.html"><strong aria-hidden="true">2.2.4.</strong> 函数</a></li></ol></li><li class="chapter-item "><a href="../basic/ownership/index.html"><strong aria-hidden="true">2.3.</strong> 所有权和借用</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../basic/ownership/ownership.html"><strong aria-hidden="true">2.3.1.</strong> 所有权</a></li><li class="chapter-item "><a href="../basic/ownership/borrowing.html"><strong aria-hidden="true">2.3.2.</strong> 引用与借用</a></li></ol></li><li class="chapter-item "><a href="../basic/compound-type/intro.html"><strong aria-hidden="true">2.4.</strong> 复合类型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../basic/compound-type/string-slice.html"><strong aria-hidden="true">2.4.1.</strong> 字符串与切片</a></li><li class="chapter-item "><a href="../basic/compound-type/tuple.html"><strong aria-hidden="true">2.4.2.</strong> 元组</a></li><li class="chapter-item "><a href="../basic/compound-type/struct.html"><strong aria-hidden="true">2.4.3.</strong> 结构体</a></li><li class="chapter-item "><a href="../basic/compound-type/enum.html"><strong aria-hidden="true">2.4.4.</strong> 枚举</a></li><li class="chapter-item "><a href="../basic/compound-type/array.html"><strong aria-hidden="true">2.4.5.</strong> 数组</a></li></ol></li><li class="chapter-item "><a href="../basic/flow-control.html"><strong aria-hidden="true">2.5.</strong> 流程控制</a></li><li class="chapter-item "><a href="../basic/match-pattern/intro.html"><strong aria-hidden="true">2.6.</strong> 模式匹配</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../basic/match-pattern/match-if-let.html"><strong aria-hidden="true">2.6.1.</strong> match和if let</a></li><li class="chapter-item "><a href="../basic/match-pattern/option.html"><strong aria-hidden="true">2.6.2.</strong> 解构Option</a></li><li class="chapter-item "><a href="../basic/match-pattern/pattern-match.html"><strong aria-hidden="true">2.6.3.</strong> 模式适用场景</a></li><li class="chapter-item "><a href="../basic/match-pattern/all-patterns.html"><strong aria-hidden="true">2.6.4.</strong> 全模式列表</a></li></ol></li><li class="chapter-item "><a href="../basic/method.html"><strong aria-hidden="true">2.7.</strong> 方法Method</a></li><li class="chapter-item "><a href="../basic/trait/intro.html"><strong aria-hidden="true">2.8.</strong> 泛型和特征</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../basic/trait/generic.html"><strong aria-hidden="true">2.8.1.</strong> 泛型Generics</a></li><li class="chapter-item "><a href="../basic/trait/trait.html"><strong aria-hidden="true">2.8.2.</strong> 特征Trait</a></li><li class="chapter-item "><a href="../basic/trait/trait-object.html"><strong aria-hidden="true">2.8.3.</strong> 特征对象</a></li><li class="chapter-item "><a href="../basic/trait/advance-trait.html"><strong aria-hidden="true">2.8.4.</strong> 进一步深入特征</a></li></ol></li><li class="chapter-item "><a href="../basic/collections/intro.html"><strong aria-hidden="true">2.9.</strong> 集合类型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../basic/collections/vector.html"><strong aria-hidden="true">2.9.1.</strong> 动态数组Vector</a></li><li class="chapter-item "><a href="../basic/collections/hashmap.html"><strong aria-hidden="true">2.9.2.</strong> KV存储HashMap</a></li></ol></li><li class="chapter-item "><a href="../basic/converse.html"><strong aria-hidden="true">2.10.</strong> 类型转换</a></li><li class="chapter-item "><a href="../basic/result-error/intro.html"><strong aria-hidden="true">2.11.</strong> 返回值和错误</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../basic/result-error/panic.html"><strong aria-hidden="true">2.11.1.</strong> panic深入剖析!</a></li><li class="chapter-item "><a href="../basic/result-error/result.html"><strong aria-hidden="true">2.11.2.</strong> 返回值Result和?</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../advance/intro.html"><strong aria-hidden="true">3.</strong> Rust高级进阶</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../advance/lifetime/intro.html"><strong aria-hidden="true">3.1.</strong> 生命周期</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../advance/lifetime/basic.html"><strong aria-hidden="true">3.1.1.</strong> 认识生命周期</a></li><li class="chapter-item "><a href="../advance/lifetime/advance.html"><strong aria-hidden="true">3.1.2.</strong> 深入生命周期</a></li></ol></li><li class="chapter-item "><a href="../advance/functional-programing/intro.html"><strong aria-hidden="true">3.2.</strong> 函数式编程</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../advance/functional-programing/closure.html"><strong aria-hidden="true">3.2.1.</strong> 闭包closure</a></li><li class="chapter-item "><a href="../advance/functional-programing/iterator.html"><strong aria-hidden="true">3.2.2.</strong> 迭代器iterator</a></li></ol></li><li class="chapter-item "><a href="../advance/crate-module/intro.html"><strong aria-hidden="true">3.3.</strong> 包和模块</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../advance/crate-module/crate.html"><strong aria-hidden="true">3.3.1.</strong> 包crate</a></li><li class="chapter-item "><a href="../advance/crate-module/module.html"><strong aria-hidden="true">3.3.2.</strong> 模块Module</a></li><li class="chapter-item "><a href="../advance/crate-module/use.html"><strong aria-hidden="true">3.3.3.</strong> 使用use引入模块及受限可见性</a></li></ol></li><li class="chapter-item "><a href="../advance/comment.html"><strong aria-hidden="true">3.4.</strong> 注释和文档</a></li><li class="chapter-item "><a href="../advance/custom-type.html"><strong aria-hidden="true">3.5.</strong> 深入类型之newtype和Sized</a></li><li class="chapter-item "><a href="../advance/formatted-output.html"><strong aria-hidden="true">3.6.</strong> 格式化输出</a></li><li class="chapter-item "><a href="../advance/smart-pointer/intro.html"><strong aria-hidden="true">3.7.</strong> 智能指针</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../advance/smart-pointer/box.html"><strong aria-hidden="true">3.7.1.</strong> Box堆对象分配</a></li><li class="chapter-item "><a href="../advance/smart-pointer/deref.html"><strong aria-hidden="true">3.7.2.</strong> Deref解引用</a></li><li class="chapter-item "><a href="../advance/smart-pointer/drop.html"><strong aria-hidden="true">3.7.3.</strong> Drop释放资源</a></li><li class="chapter-item "><a href="../advance/smart-pointer/rc-arc.html"><strong aria-hidden="true">3.7.4.</strong> Rc与Arc实现1vN所有权机制</a></li><li class="chapter-item "><a href="../advance/smart-pointer/cell-refcell.html"><strong aria-hidden="true">3.7.5.</strong> Cell与RefCell内部可变性</a></li></ol></li><li class="chapter-item "><a href="../advance/circle-self-ref/intro.html"><strong aria-hidden="true">3.8.</strong> 循环引用与自引用</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../advance/circle-self-ref/circle-reference.html"><strong aria-hidden="true">3.8.1.</strong> Weak与循环引用</a></li><li class="chapter-item "><a href="../advance/circle-self-ref/self-referential.html"><strong aria-hidden="true">3.8.2.</strong> 结构体中的自引用</a></li></ol></li><li class="chapter-item "><a href="../advance/concurrency-with-threads/intro.html"><strong aria-hidden="true">3.9.</strong> 多线程并发编程</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../advance/concurrency-with-threads/concurrency-parallelism.html"><strong aria-hidden="true">3.9.1.</strong> 并发和并行</a></li><li class="chapter-item "><a href="../advance/concurrency-with-threads/thread.html"><strong aria-hidden="true">3.9.2.</strong> 使用多线程</a></li><li class="chapter-item "><a href="../advance/concurrency-with-threads/message-passing.html"><strong aria-hidden="true">3.9.3.</strong> 线程同步：消息传递</a></li><li class="chapter-item "><a href="../advance/concurrency-with-threads/sync1.html"><strong aria-hidden="true">3.9.4.</strong> 线程同步：锁、Condvar和信号量</a></li><li class="chapter-item "><a href="../advance/concurrency-with-threads/sync2.html"><strong aria-hidden="true">3.9.5.</strong> 线程同步：Atomic原子操作与内存顺序</a></li><li class="chapter-item "><a href="../advance/concurrency-with-threads/send-sync.html"><strong aria-hidden="true">3.9.6.</strong> 基于Send和Sync的线程安全</a></li><li class="chapter-item "><a href="../advance/concurrency-with-threads/web-server.html"><strong aria-hidden="true">3.9.7.</strong> 实践应用：多线程Web服务器 todo</a></li></ol></li><li class="chapter-item "><a href="../advance/global-variable.html"><strong aria-hidden="true">3.10.</strong> 全局变量</a></li><li class="chapter-item "><a href="../advance/errors/intro.html"><strong aria-hidden="true">3.11.</strong> 错误处理 doing</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../advance/errors/simplify.html"><strong aria-hidden="true">3.11.1.</strong> 简化错误处理 todo</a></li><li class="chapter-item "><a href="../advance/errors/user-define.html"><strong aria-hidden="true">3.11.2.</strong> 自定义错误 todo</a></li><li class="chapter-item "><a href="../advance/errors/pretty-format.html"><strong aria-hidden="true">3.11.3.</strong> 让错误输出更优雅 todo</a></li><li class="chapter-item "><a href="../advance/errors/panic-codes.html"><strong aria-hidden="true">3.11.4.</strong> 会导致panic的代码 todo</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../async/intro.html"><strong aria-hidden="true">4.</strong> async/await异步编程</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../async/getting-started.html"><strong aria-hidden="true">4.1.</strong> async编程入门</a></li><li class="chapter-item "><a href="../async/future-excuting.html"><strong aria-hidden="true">4.2.</strong> 底层探秘: Future执行与任务调度</a></li><li class="chapter-item "><a href="../async/pin-unpin.html"><strong aria-hidden="true">4.3.</strong> 定海神针Pin和Unpin</a></li><li class="chapter-item "><a href="../async/async-await.html"><strong aria-hidden="true">4.4.</strong> async/await和Stream流处理</a></li><li class="chapter-item "><a href="../async/multi-futures-simultaneous.html"><strong aria-hidden="true">4.5.</strong> 同时运行多个Future</a></li><li class="chapter-item "><a href="../async/pain-points-and-workarounds.html"><strong aria-hidden="true">4.6.</strong> 一些疑难问题的解决办法</a></li><li class="chapter-item "><a href="../async/web-server.html"><strong aria-hidden="true">4.7.</strong> 实践应用：Async Web服务器</a></li></ol></li><li class="chapter-item expanded "><a href="../tokio/intro.html"><strong aria-hidden="true">5.</strong> tokio使用指南</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../tokio/overview.html"><strong aria-hidden="true">5.1.</strong> tokio概览</a></li><li class="chapter-item "><a href="../tokio/getting-startted.html"><strong aria-hidden="true">5.2.</strong> 使用初印象</a></li><li class="chapter-item "><a href="../tokio/spawning.html"><strong aria-hidden="true">5.3.</strong> 创建异步任务</a></li><li class="chapter-item "><a href="../tokio/shared-state.html"><strong aria-hidden="true">5.4.</strong> 共享状态</a></li><li class="chapter-item "><a href="../tokio/channels.html"><strong aria-hidden="true">5.5.</strong> 消息传递</a></li><li class="chapter-item "><a href="../tokio/io.html"><strong aria-hidden="true">5.6.</strong> I/O</a></li><li class="chapter-item "><a href="../tokio/frame.html"><strong aria-hidden="true">5.7.</strong> 解析数据帧</a></li><li class="chapter-item "><a href="../tokio/async.html"><strong aria-hidden="true">5.8.</strong> 深入async</a></li><li class="chapter-item "><a href="../tokio/select.html"><strong aria-hidden="true">5.9.</strong> select</a></li><li class="chapter-item "><a href="../tokio/stream.html"><strong aria-hidden="true">5.10.</strong> 类似迭代器的Stream</a></li><li class="chapter-item "><a href="../tokio/graceful-shutdown.html"><strong aria-hidden="true">5.11.</strong> 优雅的关闭</a></li><li class="chapter-item expanded "><a href="../tokio/bridging-with-sync.html" class="active"><strong aria-hidden="true">5.12.</strong> 异步跟同步共存</a></li></ol></li><li class="chapter-item expanded "><a href="../unsafe/intro.html"><strong aria-hidden="true">6.</strong> Unsafe Rust todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../unsafe/raw-pointer.html"><strong aria-hidden="true">6.1.</strong> 原生指针 todo</a></li><li class="chapter-item "><a href="../unsafe/ffi.html"><strong aria-hidden="true">6.2.</strong> FFI外部语言用 todo</a></li></ol></li><li class="chapter-item expanded "><a href="../fight-with-compiler/intro.html"><strong aria-hidden="true">7.</strong> 对抗编译检查 doing</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../fight-with-compiler/phantom-data.html"><strong aria-hidden="true">7.1.</strong> 幽灵数据(todo)</a></li><li class="chapter-item "><a href="../fight-with-compiler/lifetime/intro.html"><strong aria-hidden="true">7.2.</strong> 生命周期</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../fight-with-compiler/lifetime/too-long1.html"><strong aria-hidden="true">7.2.1.</strong> 生命周期过大-01</a></li><li class="chapter-item "><a href="../fight-with-compiler/lifetime/too-long2.html"><strong aria-hidden="true">7.2.2.</strong> 生命周期过大-02</a></li><li class="chapter-item "><a href="../fight-with-compiler/lifetime/loop.html"><strong aria-hidden="true">7.2.3.</strong> 循环中的生命周期</a></li><li class="chapter-item "><a href="../fight-with-compiler/lifetime/closure-with-static.html"><strong aria-hidden="true">7.2.4.</strong> 闭包碰到特征对象-01</a></li></ol></li><li class="chapter-item "><a href="../fight-with-compiler/borrowing/intro.html"><strong aria-hidden="true">7.3.</strong> 重复借用</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../fight-with-compiler/borrowing/ref-exist-in-out-fn.html"><strong aria-hidden="true">7.3.1.</strong> 同时在函数内外使用引用</a></li><li class="chapter-item "><a href="../fight-with-compiler/borrowing/borrow-distinct-fields-of-struct.html"><strong aria-hidden="true">7.3.2.</strong> 智能指针引起的重复借用错误</a></li></ol></li><li class="chapter-item "><a href="../fight-with-compiler/unconstrained.html"><strong aria-hidden="true">7.4.</strong> 类型未限制(todo)</a></li></ol></li><li class="chapter-item expanded "><a href="../pitfalls/index.html"><strong aria-hidden="true">8.</strong> Rust陷阱系列</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../pitfalls/use-vec-in-for.html"><strong aria-hidden="true">8.1.</strong> for循环中使用外部数组</a></li><li class="chapter-item "><a href="../pitfalls/stack-overflow.html"><strong aria-hidden="true">8.2.</strong> 线程类型导致的栈溢出</a></li><li class="chapter-item "><a href="../pitfalls/arithmetic-overflow.html"><strong aria-hidden="true">8.3.</strong> 算术溢出导致的panic</a></li><li class="chapter-item "><a href="../pitfalls/closure-with-lifetime.html"><strong aria-hidden="true">8.4.</strong> 闭包中奇怪的生命周期</a></li><li class="chapter-item "><a href="../pitfalls/the-disabled-mutability.html"><strong aria-hidden="true">8.5.</strong> 可变变量不可变？</a></li><li class="chapter-item "><a href="../pitfalls/multiple-mutable-references.html"><strong aria-hidden="true">8.6.</strong> 可变借用失败引发的深入思考</a></li><li class="chapter-item "><a href="../pitfalls/lazy-iterators.html"><strong aria-hidden="true">8.7.</strong> 不太勤快的迭代器</a></li><li class="chapter-item "><a href="../pitfalls/weird-ranges.html"><strong aria-hidden="true">8.8.</strong> 奇怪的序列x..y</a></li><li class="chapter-item "><a href="../pitfalls/iterator-everywhere.html"><strong aria-hidden="true">8.9.</strong> 无处不在的迭代器</a></li><li class="chapter-item "><a href="../pitfalls/main-with-channel-blocked.html"><strong aria-hidden="true">8.10.</strong> 线程间传递消息导致主线程无法结束</a></li></ol></li><li class="chapter-item expanded "><a href="../practice/intro.html"><strong aria-hidden="true">9.</strong> Rust最佳实践 doing</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../practice/third-party-libs.html"><strong aria-hidden="true">9.1.</strong> 日常开发三方库精选</a></li><li class="chapter-item "><a href="../practice/coding-tips.html"><strong aria-hidden="true">9.2.</strong> 一些写代码的技巧 todo</a></li><li class="chapter-item "><a href="../practice/best-pratice.html"><strong aria-hidden="true">9.3.</strong> 最佳实践 todo</a></li><li class="chapter-item "><a href="../practice/good-sourcecode.html"><strong aria-hidden="true">9.4.</strong> 值得学习的源代码 todo</a></li><li class="chapter-item "><a href="../practice/style-guide/intro.html"><strong aria-hidden="true">9.5.</strong> 代码规范 doing</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../practice/style-guide/naming.html"><strong aria-hidden="true">9.5.1.</strong> 命名规范</a></li><li class="chapter-item "><a href="../practice/style-guide/code.html"><strong aria-hidden="true">9.5.2.</strong> 代码风格(todo)</a></li><li class="chapter-item "><a href="../practice/style-guide/mark.html"><strong aria-hidden="true">9.5.3.</strong> 代码标记 todo</a></li><li class="chapter-item "><a href="../practice/style-guide/clippy.html"><strong aria-hidden="true">9.5.4.</strong> Clippy todo</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> 如何实现一个链表 todo</div></li><li class="chapter-item expanded "><a href="../converse/intro.html"><strong aria-hidden="true">11.</strong> 高级类型转换</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../converse/enum-int.html"><strong aria-hidden="true">11.1.</strong> 枚举和整数</a></li></ol></li><li class="chapter-item expanded "><a href="../cargo/intro.html"><strong aria-hidden="true">12.</strong> Cargo详解 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../cargo/commands.html"><strong aria-hidden="true">12.1.</strong> 常用命令 todo</a></li><li class="chapter-item "><a href="../cargo/layout.html"><strong aria-hidden="true">12.2.</strong> 项目结构 todo</a></li><li class="chapter-item "><a href="../cargo/cargo-toml-lock.html"><strong aria-hidden="true">12.3.</strong> Cargo.toml和Cargo.lock todo</a></li><li class="chapter-item "><a href="../cargo/dependency.html"><strong aria-hidden="true">12.4.</strong> 依赖管理 todo</a></li><li class="chapter-item "><a href="../cargo/cache.html"><strong aria-hidden="true">12.5.</strong> 构建缓存 todo</a></li><li class="chapter-item "><a href="../cargo/version.html"><strong aria-hidden="true">12.6.</strong> 版本管理 todo</a></li><li class="chapter-item "><a href="../cargo/workspace.html"><strong aria-hidden="true">12.7.</strong> 工作空间 todo</a></li><li class="chapter-item "><a href="../cargo/feature.html"><strong aria-hidden="true">12.8.</strong> 条件编译、条件依赖 todo</a></li><li class="chapter-item "><a href="../cargo/manifest.html"><strong aria-hidden="true">12.9.</strong> 配置参数 todo</a></li><li class="chapter-item "><a href="../cargo/build-js.html"><strong aria-hidden="true">12.10.</strong> 自定义构建脚本 todo</a></li><li class="chapter-item "><a href="../cargo/profile.html"><strong aria-hidden="true">12.11.</strong> Cargo profile todo</a></li></ol></li><li class="chapter-item expanded "><a href="../test/intro.html"><strong aria-hidden="true">13.</strong> 测试 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../test/unit.html"><strong aria-hidden="true">13.1.</strong> 单元测试 todo</a></li><li class="chapter-item "><a href="../test/intergration.html"><strong aria-hidden="true">13.2.</strong> 集成测试 todo</a></li><li class="chapter-item "><a href="../test/benchmark.html"><strong aria-hidden="true">13.3.</strong> 性能测试 todo</a></li><li class="chapter-item "><a href="../test/ci.html"><strong aria-hidden="true">13.4.</strong> 持续集成 todo</a></li></ol></li><li class="chapter-item expanded "><a href="../traits/intro.html"><strong aria-hidden="true">14.</strong> 常见特征解析 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../traits/from-into.html"><strong aria-hidden="true">14.1.</strong> 类型转换From/Into todo</a></li><li class="chapter-item "><a href="../traits/as-ref-as-mut.html"><strong aria-hidden="true">14.2.</strong> AsRef, AsMut todo</a></li><li class="chapter-item "><a href="../traits/borrow-family.html"><strong aria-hidden="true">14.3.</strong> Borrow, BorrowMut, ToOwned todo</a></li><li class="chapter-item "><a href="../traits/deref.html"><strong aria-hidden="true">14.4.</strong> Deref和引用隐式转换 todo</a></li><li class="chapter-item "><a href="../traits/cow.html"><strong aria-hidden="true">14.5.</strong> 写时拷贝Cow todo</a></li><li class="chapter-item "><a href="../traits/eq.html"><strong aria-hidden="true">14.6.</strong> Eq todo</a></li></ol></li><li class="chapter-item expanded "><a href="../memory/intro.html"><strong aria-hidden="true">15.</strong> 深入内存 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../memory/pointer-ref.html"><strong aria-hidden="true">15.1.</strong> 指针和引用 todo</a></li><li class="chapter-item "><a href="../memory/uninit.html"><strong aria-hidden="true">15.2.</strong> 未初始化内存 todo</a></li><li class="chapter-item "><a href="../memory/allocation.html"><strong aria-hidden="true">15.3.</strong> 内存分配 todo</a></li><li class="chapter-item "><a href="../memory/layout.html"><strong aria-hidden="true">15.4.</strong> 内存布局 todo</a></li><li class="chapter-item "><a href="../memory/virtual.html"><strong aria-hidden="true">15.5.</strong> 虚拟内存 todo</a></li></ol></li><li class="chapter-item expanded "><a href="../web/intro.html"><strong aria-hidden="true">16.</strong> Web应用开发 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../web/serialization.html"><strong aria-hidden="true">16.1.</strong> 编解码与序列化 todo</a></li></ol></li><li class="chapter-item expanded "><a href="../object-oriented/intro.html"><strong aria-hidden="true">17.</strong> 面向对象 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../object-oriented/characteristics.html"><strong aria-hidden="true">17.1.</strong> 为何OO todo</a></li><li class="chapter-item "><a href="../object-oriented/design-pattern.html"><strong aria-hidden="true">17.2.</strong> 设计模式 todo</a></li></ol></li><li class="chapter-item expanded "><a href="../macro/intro.html"><strong aria-hidden="true">18.</strong> 宏编程 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../macro/procedure-macro.html"><strong aria-hidden="true">18.1.</strong> 过程宏(todo)</a></li></ol></li><li class="chapter-item expanded "><a href="../performance/intro.html"><strong aria-hidden="true">19.</strong> 性能调优 doing</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../performance/deep-into-move.html"><strong aria-hidden="true">19.1.</strong> 深入理解move</a></li><li class="chapter-item "><a href="../performance/early-optimise.html"><strong aria-hidden="true">19.2.</strong> 糟糕的提前优化 todo</a></li><li class="chapter-item "><a href="../performance/clone-copy.html"><strong aria-hidden="true">19.3.</strong> Clone和Copy todo</a></li><li class="chapter-item "><a href="../performance/benchmark.html"><strong aria-hidden="true">19.4.</strong> Benchmark性能测试(todo)</a></li><li class="chapter-item "><a href="../performance/runtime-check.html"><strong aria-hidden="true">19.5.</strong> 减少Runtime check(todo)</a></li><li class="chapter-item "><a href="../performance/cpu-cache.html"><strong aria-hidden="true">19.6.</strong> CPU缓存性能优化 todo</a></li><li class="chapter-item "><a href="../performance/calculate.html"><strong aria-hidden="true">19.7.</strong> 计算性能优化 todo</a></li><li class="chapter-item "><a href="../performance/heap-stack.html"><strong aria-hidden="true">19.8.</strong> 堆和栈 todo</a></li><li class="chapter-item "><a href="../performance/allocator.html"><strong aria-hidden="true">19.9.</strong> 内存allocator todo</a></li><li class="chapter-item "><a href="../performance/tools.html"><strong aria-hidden="true">19.10.</strong> 常用性能测试工具 todo</a></li><li class="chapter-item "><a href="../performance/enum.html"><strong aria-hidden="true">19.11.</strong> Enum内存优化 todo</a></li></ol></li><li class="chapter-item expanded "><a href="../compiler/intro.html"><strong aria-hidden="true">20.</strong> 编译器 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../compiler/attributes.html"><strong aria-hidden="true">20.1.</strong> 常见属性标记 todo</a></li><li class="chapter-item "><a href="../compiler/speed-up.html"><strong aria-hidden="true">20.2.</strong> 提升编译速度 todo</a></li><li class="chapter-item "><a href="../compiler/optimization/intro.html"><strong aria-hidden="true">20.3.</strong> 编译器优化 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../compiler/optimization/option.html"><strong aria-hidden="true">20.3.1.</strong> Option枚举 todo</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../monitor/intro.html"><strong aria-hidden="true">21.</strong> 日志和监控 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../monitor/log.html"><strong aria-hidden="true">21.1.</strong> 日志 todo</a></li><li class="chapter-item "><a href="../monitor/observability.html"><strong aria-hidden="true">21.2.</strong> 可观测性 todo</a></li><li class="chapter-item "><a href="../monitor/apm.html"><strong aria-hidden="true">21.3.</strong> 监控(APM) todo</a></li></ol></li><li class="chapter-item expanded "><a href="../std/intro.html"><strong aria-hidden="true">22.</strong> 标准库解析 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../std/search.html"><strong aria-hidden="true">22.1.</strong> 标准库使用最佳时间 todo</a></li><li class="chapter-item "><a href="../std/vector.html"><strong aria-hidden="true">22.2.</strong> Vector常用方法 todo</a></li><li class="chapter-item "><a href="../std/hashmap.html"><strong aria-hidden="true">22.3.</strong> HashMap todo</a></li><li class="chapter-item "><a href="../std/iterator.html"><strong aria-hidden="true">22.4.</strong> Iterator常用方法 todo</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">23.</strong> Rust区块链入门</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">24.</strong> Rust游戏开发入门</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">25.</strong> Rust前端开发入门</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">26.</strong> Rust和WASM</div></li><li class="chapter-item expanded "><a href="../appendix/intro.html"><strong aria-hidden="true">27.</strong> 附录</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../appendix/keywords.html"><strong aria-hidden="true">27.1.</strong> A-关键字</a></li><li class="chapter-item "><a href="../appendix/operators.html"><strong aria-hidden="true">27.2.</strong> B-运算符与符号</a></li><li class="chapter-item "><a href="../appendix/expressions.html"><strong aria-hidden="true">27.3.</strong> C-表达式</a></li><li class="chapter-item "><a href="../appendix/derive.html"><strong aria-hidden="true">27.4.</strong> D-派生特征derive</a></li><li class="chapter-item "><a href="../appendix/prelude.html"><strong aria-hidden="true">27.5.</strong> E-prelude模块 todo</a></li><li class="chapter-item "><a href="../appendix/difficulties.html"><strong aria-hidden="true">27.6.</strong> F-难点索引</a></li><li class="chapter-item "><a href="../appendix/rust-version.html"><strong aria-hidden="true">27.7.</strong> G-Rust版本说明</a></li><li class="chapter-item "><a href="../appendix/rust-versions/intro.html"><strong aria-hidden="true">27.8.</strong> H-Rust更新版本列表</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../appendix/rust-versions/1.58.html"><strong aria-hidden="true">27.8.1.</strong> 1.58</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust语言圣经(Rust教程 Rust Course)</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/sunface/rust-course" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/sunface/rust-course/edit/main/book/contents/tokio/bridging-with-sync.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="异步跟同步共存"><a class="header" href="#异步跟同步共存">异步跟同步共存</a></h1>
<p>一些异步程序例如 tokio指南 章节中的绝大多数例子，它们整个程序都是异步的，包括程序入口 <code>main</code> 函数：</p>
<pre><pre class="playground"><code class="language-rust edition2021">#[tokio::main]
async fn main() {
    println!(&quot;Hello world&quot;);
}
</code></pre></pre>
<p>在一些场景中，你可能只想在异步程序中运行一小部分同步代码，这种需求可以考虑下 <a href="https://docs.rs/tokio/1.16.1/tokio/task/fn.spawn_blocking.html"><code>spawn_blocking</code></a>。</p>
<p>但是在很多场景中，我们只想让程序的某一个部分成为异步的，也许是因为同步代码更好实现，又或许是同步代码可读性、兼容性都更好。例如一个 <code>GUI</code> 应用可能想要让 <code>UI</code> 相关的代码在主线程中，然后通过另一个线程使用 <code>tokio</code> 的运行时来处理一些异步任务。</p>
<p>因此本章节的目标很纯粹：如何在同步代码中使用一小部分异步代码。</p>
<h2 id="tokiomain-的展开"><a class="header" href="#tokiomain-的展开"><code>#[tokio::main]</code> 的展开</a></h2>
<p>在 Rust 中， <code>main</code> 函数不能是异步的，有同学肯定不愿意了，我们在之前章节..不对，就在开头，你还用到了 <code>async  fn main</code> 的声明方式，怎么就不能异步了呢？</p>
<p>其实，<code>#[tokio::main]</code> 该宏仅仅是提供语法糖，目的是让大家可以更简单、更一致的去写异步代码，它会将你写下的<code>async fn main</code> 函数替换为：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    tokio::runtime::Builder::new_multi_thread()
        .enable_all()
        .build()
        .unwrap()
        .block_on(async {
            println!(&quot;Hello world&quot;);
        })
}
</code></pre></pre>
<p>注意到上面的 <code>block_on</code> 方法了嘛？在我们自己的同步代码中，可以使用它开启一个 <code>async/await</code> 世界。</p>
<h2 id="mini-redis的同步接口"><a class="header" href="#mini-redis的同步接口">mini-redis的同步接口</a></h2>
<p>在下面，我们将一起构建一个同步的 <code>mini-redis</code> ，为了实现这一点，需要将 <code>Runtime</code> 对象存储起来，然后利用上面提到的 <code>block_on</code> 方法。</p>
<p>首先，创建一个文件 <code>src/blocking_client.rs</code>，然后使用下面代码将异步的 <code>Clien</code> 结构体包裹起来:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::net::ToSocketAddrs;
use tokio::runtime::Runtime;

pub use crate::client::Message;

/// 建立到 redis 服务端的连接
pub struct BlockingClient {
    /// 之前实现的异步客户端 `Client`
    inner: crate::client::Client,

    /// 一个 `current_thread` 模式的 `tokio` 运行时，
    /// 使用阻塞的方式来执行异步客户端 `Client` 上的操作
    rt: Runtime,
}

pub fn connect&lt;T: ToSocketAddrs&gt;(addr: T) -&gt; crate::Result&lt;BlockingClient&gt; {
    // 构建一个 tokio 运行时： Runtime
    let rt = tokio::runtime::Builder::new_current_thread()
        .enable_all()
        .build()?;

    // 使用运行时来调用异步的连接方法
    let inner = rt.block_on(crate::client::connect(addr))?;

    Ok(BlockingClient { inner, rt })
}
<span class="boring">}
</span></code></pre></pre>
<p>在这里，我们使用了一个构造器函数用于在同步代码中执行异步的方法：使用 <code>Runtime</code> 上的 <code>block_on</code> 方法来执行一个异步方法并返回结果。</p>
<p>有一个很重要的点，就是我们还使用了 <a href="https://docs.rs/tokio/1.16.1/tokio/runtime/struct.Builder.html#method.new_current_thread"><code>current_thread</code></a> 模式的运行时。这个可不常见，原因是异步程序往往要利用多线程的威力来实现更高的吞吐性能，相对应的模式就是 <a href="https://docs.rs/tokio/1.16.1/tokio/runtime/struct.Builder.html#method.new_multi_thread"><code>multi_thread</code></a>，该模式会生成多个运行在后台的线程，它们可以高效的实现多个任务的同时并行处理。</p>
<p>但是对于我们的使用场景来说，在同一时间点只需要做一件事，无需并行处理，多个线程并不能帮助到任何事情，因此 <code>current_thread</code> 此时成为了最佳的选择。</p>
<p>在构建 <code>Runtime</code> 的过程中还有一个 <a href="https://docs.rs/tokio/1.16.1/tokio/runtime/struct.Builder.html#method.enable_all"><code>enable_all</code></a> 方法调用，它可以开启 <code>Tokio</code> 运行时提供的 IO 和定时器服务。</p>
<blockquote>
<p>由于 <code>current_thread</code> 运行时并不生成新的线程，只是运行在已有的主线程上，因此只有当 <code>block_on</code> 被调用后，该运行时才能执行相应的操作。一旦 <code>block_on</code> 返回，那运行时上所有生成的任务将再次冻结，直到 <code>block_on</code> 的再次调用。</p>
<p>如果这种模式不符合使用场景的需求，那大家还是需要用 <code>multi_thread</code> 运行时来代替。事实上，在 tokio 之前的章节中，我们默认使用的就是 <code>multi_thread</code> 模式。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bytes::Bytes;
use std::time::Duration;

impl BlockingClient {
    pub fn get(&amp;mut self, key: &amp;str) -&gt; crate::Result&lt;Option&lt;Bytes&gt;&gt; {
        self.rt.block_on(self.inner.get(key))
    }

    pub fn set(&amp;mut self, key: &amp;str, value: Bytes) -&gt; crate::Result&lt;()&gt; {
        self.rt.block_on(self.inner.set(key, value))
    }

    pub fn set_expires(
        &amp;mut self,
        key: &amp;str,
        value: Bytes,
        expiration: Duration,
    ) -&gt; crate::Result&lt;()&gt; {
        self.rt.block_on(self.inner.set_expires(key, value, expiration))
    }

    pub fn publish(&amp;mut self, channel: &amp;str, message: Bytes) -&gt; crate::Result&lt;u64&gt; {
        self.rt.block_on(self.inner.publish(channel, message))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这代码看上去挺长，实际上很简单，通过 <code>block_on</code> 将异步形式的 <code>Client</code> 的法变成同步调用的形式。例如 <code>BlockingClient</code> 的 <code>get</code> 方法实际上是对内部的异步 <code>get</code> 方法的同步调用。</p>
<p>与上面的平平无奇相比，下面的代码将更有趣，因为它将 <code>Client</code> 转变成一个 <code>Subscriber</code> 对象:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 下面的客户端可以进入 pub/sub (发布/订阅) 模式
///
/// 一旦客户端订阅了某个消息通道，那就只能执行 pub/sub 相关的命令。
/// 将`BlockingClient` 类型转换成 `BlockingSubscriber` 是为了防止非 `pub/sub` 方法被调用
pub struct BlockingSubscriber {
    /// 异步版本的 `Subscriber`
    inner: crate::client::Subscriber,

    /// 一个 `current_thread` 模式的 `tokio` 运行时，
    /// 使用阻塞的方式来执行异步客户端 `Client` 上的操作
    rt: Runtime,
}

impl BlockingClient {
    pub fn subscribe(self, channels: Vec&lt;String&gt;) -&gt; crate::Result&lt;BlockingSubscriber&gt; {
        let subscriber = self.rt.block_on(self.inner.subscribe(channels))?;
        Ok(BlockingSubscriber {
            inner: subscriber,
            rt: self.rt,
        })
    }
}

impl BlockingSubscriber {
    pub fn get_subscribed(&amp;self) -&gt; &amp;[String] {
        self.inner.get_subscribed()
    }

    pub fn next_message(&amp;mut self) -&gt; crate::Result&lt;Option&lt;Message&gt;&gt; {
        self.rt.block_on(self.inner.next_message())
    }

    pub fn subscribe(&amp;mut self, channels: &amp;[String]) -&gt; crate::Result&lt;()&gt; {
        self.rt.block_on(self.inner.subscribe(channels))
    }

    pub fn unsubscribe(&amp;mut self, channels: &amp;[String]) -&gt; crate::Result&lt;()&gt; {
        self.rt.block_on(self.inner.unsubscribe(channels))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>由上可知，<code>subscribe</code> 方法会使用运行时将一个异步的 <code>Client</code> 转变成一个异步的 <code>Subscriber</code>，此外，<code>Subscriber</code> 结构体有一个非异步的方法 <code>get_subscribed</code>，对于这种方法，只需直接调用即可，而无需使用运行时。</p>
<h2 id="其它方法"><a class="header" href="#其它方法">其它方法</a></h2>
<p>上面介绍的是最简单的方法，但是，如果只有这一种， tokio 也不会成为今天这个大名鼎鼎的自己。</p>
<h4 id="runtimespawn"><a class="header" href="#runtimespawn">runtime.spawn</a></h4>
<p>可以通过 <code>Runtime</code> 的 <code>spawn</code> 方法来创建一个基于该运行时的后台任务：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use tokio::runtime::Builder;
use tokio::time::{sleep, Duration};

fn main() {
    let runtime = Builder::new_multi_thread()
        .worker_threads(1)
        .enable_all()
        .build()
        .unwrap();

    let mut handles = Vec::with_capacity(10);
    for i in 0..10 {
        handles.push(runtime.spawn(my_bg_task(i)));
    }

    // 在后台任务运行的同时做一些耗费时间的事情
    std::thread::sleep(Duration::from_millis(750));
    println!(&quot;Finished time-consuming task.&quot;);

    // 等待这些后台任务的完成
    for handle in handles {
        // `spawn` 方法返回一个 `JoinHandle`，它是一个 `Future`，因此可以通过  `block_on` 来等待它完成
        runtime.block_on(handle).unwrap();
    }
}

async fn my_bg_task(i: u64) {
    let millis = 1000 - 50 * i;
    println!(&quot;Task {} sleeping for {} ms.&quot;, i, millis);

    sleep(Duration::from_millis(millis)).await;

    println!(&quot;Task {} stopping.&quot;, i);
}
</code></pre></pre>
<p>运行该程序，输出如下:</p>
<pre><code class="language-console">Task 0 sleeping for 1000 ms.
Task 1 sleeping for 950 ms.
Task 2 sleeping for 900 ms.
Task 3 sleeping for 850 ms.
Task 4 sleeping for 800 ms.
Task 5 sleeping for 750 ms.
Task 6 sleeping for 700 ms.
Task 7 sleeping for 650 ms.
Task 8 sleeping for 600 ms.
Task 9 sleeping for 550 ms.
Task 9 stopping.
Task 8 stopping.
Task 7 stopping.
Task 6 stopping.
Finished time-consuming task.
Task 5 stopping.
Task 4 stopping.
Task 3 stopping.
Task 2 stopping.
Task 1 stopping.
Task 0 stopping.
</code></pre>
<p>在此例中，我们生成了10个后台任务在运行时中运行，然后等待它们的完成。作为一个例子，想象一下在图形渲染应用( GUI )中，有时候需要通过网络访问远程服务来获取一些数据，那上面的这种模式就非常适合，因为这些网络访问比较耗时，而且不会影响图形的主体渲染，因此可以在主线程中渲染图形，然后使用其它线程来运行 Tokio 的运行时，并通过该运行时使用异步的方式完成网络访问，最后将这些网络访问的结果发送到 GUI 进行数据渲染，例如一个进度条。</p>
<p>还有一点很重要，在本例子中只能使用 <code>multi_thread</code> 运行时。如果我们使用了 <code>current_thread</code>，你会发现主线程的耗时任务会在后台任务开始之前就完成了。因为在 <code>multi_thread</code> 模式下，生成的任务只会在 <code>block_on</code> 期间才执行。</p>
<p>在 <code>multi_thread</code> 模式下，我们并不需要通过 <code>block_on</code> 来触发任务的运行，这里是仅仅是用来阻塞并等待最终的结果。而除了通过 <code>block_on</code> 等待结果外，你还可以：</p>
<ul>
<li>使用消息传递的方式，例如 <code>tokio::sync::mpsc</code>，让异步任务将结果发送到主线程，然后主线程通过 <code>.recv</code>方法等待这些结果</li>
<li>通过共享变量的方式，例如 <code>Mutex</code>，这种方式非常适合实现 GUI 的进度条: GUI 在每个渲染帧读取该变量即可。</li>
</ul>
<h4 id="发送消息"><a class="header" href="#发送消息">发送消息</a></h4>
<p>在同步代码中使用异步的另一个方法就是生成一个运行时，然后使用消息传递的方式跟它进行交互。这个方法虽然更啰嗦一些，但是相对于之前的两种方法更加灵活：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::runtime::Builder;
use tokio::sync::mpsc;

pub struct Task {
    name: String,
    // 一些信息用于描述该任务
}

async fn handle_task(task: Task) {
    println!(&quot;Got task {}&quot;, task.name);
}

#[derive(Clone)]
pub struct TaskSpawner {
    spawn: mpsc::Sender&lt;Task&gt;,
}

impl TaskSpawner {
    pub fn new() -&gt; TaskSpawner {
        // 创建一个消息通道用于通信
        let (send, mut recv) = mpsc::channel(16);

        let rt = Builder::new_current_thread()
            .enable_all()
            .build()
            .unwrap();

        std::thread::spawn(move || {
            rt.block_on(async move {
                while let Some(task) = recv.recv().await {
                    tokio::spawn(handle_task(task));
                }

                // 一旦所有的发送端超出作用域被 drop 后，`.recv()` 方法会返回 None，同时 while 循环会退出，然后线程结束
            });
        });

        TaskSpawner {
            spawn: send,
        }
    }

    pub fn spawn_task(&amp;self, task: Task) {
        match self.spawn.blocking_send(task) {
            Ok(()) =&gt; {},
            Err(_) =&gt; panic!(&quot;The shared runtime has shut down.&quot;),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>为何说这种方法比较灵活呢？以上面代码为例，它可以在很多方面进行配置。例如，可以使用信号量 <a href="https://docs.rs/tokio/1.16.1/tokio/sync/struct.Semaphore.html"><code>Semaphore</code></a>来限制当前正在进行的任务数，或者你还可以使用一个消息通道将消息反向发送回任务生成器 <code>spawner</code>。</p>
<p>抛开细节，抽象来看，这是不是很像一个 Actor ？</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../tokio/graceful-shutdown.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../unsafe/intro.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../tokio/graceful-shutdown.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../unsafe/intro.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script type="text/javascript">
            window.playground_line_numbers = true;
        </script>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>

        <script src="../ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="../editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="../theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="../theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../assets/ferris.js"></script>


    </body>
</html>
